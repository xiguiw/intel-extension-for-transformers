:orphan:

:py:mod:`intel_extension_for_transformers.llm.runtime.graph.scripts.convert_mistral`
====================================================================================

.. py:module:: intel_extension_for_transformers.llm.runtime.graph.scripts.convert_mistral


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   intel_extension_for_transformers.llm.runtime.graph.scripts.convert_mistral.NEFileType
   intel_extension_for_transformers.llm.runtime.graph.scripts.convert_mistral.LazyUnpickler



Functions
~~~~~~~~~

.. autoapisummary::

   intel_extension_for_transformers.llm.runtime.graph.scripts.convert_mistral.handle_quantization
   intel_extension_for_transformers.llm.runtime.graph.scripts.convert_mistral.bounded_parallel_map
   intel_extension_for_transformers.llm.runtime.graph.scripts.convert_mistral.nth_multifile_path
   intel_extension_for_transformers.llm.runtime.graph.scripts.convert_mistral.find_multifile_paths
   intel_extension_for_transformers.llm.runtime.graph.scripts.convert_mistral.load_some_model



.. py:class:: NEFileType




   Generic enumeration.

   Derive from this class to define new enumerations.


.. py:function:: handle_quantization(model: LazyModel) -> LazyModel

   Convert a model with entries for 'foo.qweight', 'foo.scales', etc.
   (which resolve to UnquantizedTensors with the raw data) to one with entries
   for 'foo.weight' (which resolve to QuantizedTensors).


.. py:class:: LazyUnpickler(fp: IO[bytes], data_base_path: str, zip_file: zipfile.ZipFile)




   This takes a binary file for reading a pickle data stream.

   The protocol version of the pickle is detected automatically, so no
   protocol argument is needed.  Bytes past the pickled object's
   representation are ignored.

   The argument *file* must have two methods, a read() method that takes
   an integer argument, and a readline() method that requires no
   arguments.  Both methods should return bytes.  Thus *file* can be a
   binary file object opened for reading, an io.BytesIO object, or any
   other custom object that meets this interface.

   Optional keyword arguments are *fix_imports*, *encoding* and *errors*,
   which are used to control compatibility support for pickle stream
   generated by Python 2.  If *fix_imports* is True, pickle will try to
   map the old Python 2 names to the new names used in Python 3.  The
   *encoding* and *errors* tell pickle how to decode 8-bit string
   instances pickled by Python 2; these default to 'ASCII' and 'strict',
   respectively.  The *encoding* can be 'bytes' to read these 8-bit
   string instances as bytes objects.

   .. py:method:: find_class(module: str, name: str) -> Any

      Return an object from a specified module.

      If necessary, the module will be imported. Subclasses may override
      this method (e.g. to restrict unpickling of arbitrary classes and
      functions).

      This method is called whenever a class or a function object is
      needed.  Both arguments passed are str objects.



.. py:function:: bounded_parallel_map(func: Callable[[In], Out], iterable: Iterable[In], concurrency: int) -> Iterable[Out]

   Parallel map, but with backpressure.  If the caller doesn't call `next`
   fast enough, this will stop calling `func` at some point rather than
   letting results pile up in memory.  Specifically, there is a max of one
   output value buffered per thread.


.. py:function:: nth_multifile_path(path: pathlib.Path, n: int) -> Optional[pathlib.Path]

   Given any path belonging to a multi-file model (e.g. foo.bin.1), return
   the nth path in the model.


.. py:function:: find_multifile_paths(path: pathlib.Path) -> List[pathlib.Path]

   Given any path belonging to a multi-file model (e.g. foo.bin.1), return
   the whole list of paths in the model.


.. py:function:: load_some_model(path: pathlib.Path) -> ModelPlus

   Load a model of any supported format.


